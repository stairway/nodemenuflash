package com.nodemenu {		import flash.display.Sprite;	import flash.display.Graphics;	import flash.geom.Point;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.net.URLRequest;	import flash.net.URLLoader;		import fl.transitions.Tween;	import fl.transitions.TweenEvent;		import com.greensock.*;	import com.greensock.easing.*;	import com.greensock.OverwriteManager;		import com.nodemenu.NodeButton;	import com.nodemenu.ConfigureNode;			public class NodeMenu extends Sprite {				public var menuActive:Boolean;				public var diameter:Number;				private var _width:Number;		private var _height:Number;				private var _mainBtn:NodeButton;		private var _buttons:Array;		private var _hitArea:Sprite;		private var _origin:Point;				private var _buttonsTween:Array;		private var _buttonsTweenSorted:Boolean;		private var _currentTweenButton:NodeButton;		private var _currentTweenIndex:uint;		private var _tweenDelay:Timer;				private var xmlLoader:URLLoader = new URLLoader();		private var xmlData:XML = new XML();		private var xmlLoaded:Boolean = false;				private var _configXml:String;		private var _nodeCount:uint;		private var _nodeOffset:Number;		private var _angleOffset:Number;		private var _nodeInitialDiameter:Number;		private var _nodeFinalDiameter:Number;		private var _openEffect:uint; // 1:NO_EFFECT (CLOCKWISE), 2:REVERSE (COUNTER-CLOCKWISE), 3:SIMULTANEOUS, 4:RANDOM		private var _closeEffect:uint; // 1:NO_EFFECT (CLOCKWISE), 2:REVERSE (COUNTER-CLOCKWISE), 3:SIMULTANEOUS, 4:RANDOM				private var _readyDispatched:Boolean = false;								/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::		INITIALIZATION		::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/		private function init():void {			_buttons = [];			mouseEnabled = false;		}				private function LoadXml():void {			xmlLoader.addEventListener(Event.COMPLETE, onXmlLoaded);			xmlLoader.load(new URLRequest(_configXml));		}				private function onXmlLoaded(e:Event):void {			xmlLoader.removeEventListener(Event.COMPLETE, onXmlLoaded);			xmlData = new XML(e.target.data);			xmlLoaded = true;			dispatchEvent(new NodeEvent(NodeEvent.XML_LOADED));		}				public function ParseXml(e:NodeEvent):void  {			removeEventListener(NodeEvent.XML_LOADED,ParseXml);						if(xmlData.hasOwnProperty("nodeMenu")) {				if(xmlData.nodeMenu.hasOwnProperty("nodeButtons")) {					if(xmlData.nodeMenu.nodeButtons.hasOwnProperty("openEffect")) {					_openEffect = xmlData.nodeMenu.nodeButtons.openEffect;					}					if(xmlData.nodeMenu.nodeButtons.hasOwnProperty("closeEffect")) {						_closeEffect = xmlData.nodeMenu.nodeButtons.closeEffect;					}					if(xmlData.nodeMenu.nodeButtons.hasOwnProperty("nodeButton")) {						_nodeCount = xmlData.nodeMenu.nodeButtons.nodeButton.length();					}					if(xmlData.nodeMenu.nodeButtons.hasOwnProperty("nodeOffset")) {						_nodeOffset = xmlData.nodeMenu.nodeButtons.nodeOffset;					}					if(xmlData.nodeMenu.nodeButtons.hasOwnProperty("angleOffset")) {						_angleOffset = xmlData.nodeMenu.nodeButtons.angleOffset;					}					if(xmlData.nodeMenu.nodeButtons.hasOwnProperty("initialDiameter")) {						_nodeInitialDiameter = xmlData.nodeMenu.nodeButtons.initialDiameter;					}					if(xmlData.nodeMenu.nodeButtons.hasOwnProperty("finalDiameter")) {						_nodeFinalDiameter = xmlData.nodeMenu.nodeButtons.finalDiameter;					}				}					}						constructMenu();						dispatchEvent(new NodeEvent(NodeEvent.READY));			_readyDispatched = true;		}				/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::		CONSTRUCTOR		::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/		public function NodeMenu(configXml:String) {			_configXml = configXml;			init();			addEventListener(NodeEvent.XML_LOADED,ParseXml);			LoadXml();			addEventListener(Event.ENTER_FRAME,enterFrame_handler);		}				public function getSize() {			this.diameter = this._width;			return this.diameter;		}				private function enterFrame_handler(e:Event):void {			if(xmlLoaded) {				switch(_mainBtn.buttonActive) {					case true:						activateMenu();						break;										case false:						disableMenu();						break;				}			}		}				private function constructMenu():void {			if(xmlData.nodeMenu.hasOwnProperty("mainBtn")) {				createMainButton(xmlData.nodeMenu.mainBtn);			}			createNodeButtons();						displayButtons();						_origin = new Point(_mainBtn.x,_mainBtn.y);						try {				createHitArea();			} catch(e:Error) {				trace("createHitArea(): " + e);			}		}				private function createNodeButtons():void {			var count = 0;						if(xmlData.nodeMenu.hasOwnProperty("nodeButtons")) {				var nodeButtonList:XMLList = xmlData.nodeMenu.nodeButtons.nodeButton;				for each (var node:XML in nodeButtonList) {					createNodeButton(node);					count++;				}							}					}				public function createMainButton(node) {			var nodeConf:ConfigureNode = new ConfigureNode();			if(node.hasOwnProperty("nodeName")) {				nodeConf.nodeName = node.nodeName;			}			if(node.hasOwnProperty("initialDiameter")) {				nodeConf.initialDiameter = node.initialDiameter;			}			if(node.hasOwnProperty("finalDiameter")) {				nodeConf.finalDiameter = node.finalDiameter;			}			if(node.hasOwnProperty("fillColor")) {				nodeConf.fillColor = node.fillColor;			}			if(node.hasOwnProperty("fillAlpha")) {				nodeConf.fillAlpha = node.fillAlpha;			}			if(node.hasOwnProperty("borderColor")) {				nodeConf.borderColor = node.borderColor;			}			if(node.hasOwnProperty("borderThickness")) {				nodeConf.borderThickness = node.borderThickness;			}			if(node.hasOwnProperty("borderAlpha")) {				nodeConf.borderAlpha = node.borderAlpha;			}			if(node.hasOwnProperty("initialAlpha")) {				nodeConf.initialAlpha = node.initialAlpha;			}			if(node.hasOwnProperty("finalAlpha")) {				nodeConf.finalAlpha = node.finalAlpha;			}						if(node.hasOwnProperty("contentIsImage")) {				if(node.contentIsImage == "true") {					nodeConf.contentIsImage = true;				} else {					nodeConf.contentIsImage = false;				}			}			if(node.hasOwnProperty("nodeContent")) {				nodeConf.nodeContent = node.nodeContent;			}			if(node.hasOwnProperty("nodeHref")) {				nodeConf.nodeHref = node.nodeHref;			}			if(node.hasOwnProperty("nodeContentSize")) {				nodeConf.nodeContentSize = node.nodeContentSize;			}			if(node.hasOwnProperty("nodeContentFont")) {				nodeConf.nodeContentFont = node.nodeContentFont;			}			if(node.hasOwnProperty("nodeContentColor")) {				nodeConf.nodeContentColor = node.nodeContentColor;			}			if(node.hasOwnProperty("nodeContentAlign")) {				nodeConf.nodeContentAlign = node.nodeContentAlign;			}			if(node.hasOwnProperty("nodeContentAlpha")) {				nodeConf.nodeContentAlpha = node.nodeContentAlpha;			}						_mainBtn = new NodeButton(nodeConf);			addChild(_mainBtn);		}				public function createNodeButton(node):void {			var nodeConf:ConfigureNode = new ConfigureNode();			if(node.hasOwnProperty("nodeName")) {				nodeConf.nodeName = node.nodeName;			}			nodeConf.initialDiameter = _nodeInitialDiameter;			nodeConf.finalDiameter = _nodeFinalDiameter;			if(node.hasOwnProperty("fillColor")) {				nodeConf.fillColor = node.fillColor;			}			if(node.hasOwnProperty("fillAlpha")) {				nodeConf.fillAlpha = node.fillAlpha;			}			if(node.hasOwnProperty("borderColor")) {				nodeConf.borderColor = node.borderColor;			}			if(node.hasOwnProperty("borderThickness")) {				nodeConf.borderThickness = node.borderThickness;			}			if(node.hasOwnProperty("borderAlpha")) {				nodeConf.borderAlpha = node.borderAlpha;			}			if(node.hasOwnProperty("initialAlpha")) {				nodeConf.initialAlpha = node.initialAlpha;			}			if(node.hasOwnProperty("finalAlpha")) {				nodeConf.finalAlpha = node.finalAlpha;			}						if(node.hasOwnProperty("contentIsImage")) {				if(node.contentIsImage == "true") {					nodeConf.contentIsImage = true;				} else {					nodeConf.contentIsImage = false;				}			}			if(node.hasOwnProperty("nodeContent")) {				nodeConf.nodeContent = node.nodeContent;			}			if(node.hasOwnProperty("nodeHref")) {				nodeConf.nodeHref = node.nodeHref;			}			if(node.hasOwnProperty("nodeContentSize")) {				nodeConf.nodeContentSize = node.nodeContentSize;			}			if(node.hasOwnProperty("nodeContentFont")) {				nodeConf.nodeContentFont = node.nodeContentFont;			}			if(node.hasOwnProperty("nodeContentColor")) {				nodeConf.nodeContentColor = node.nodeContentColor;			}			if(node.hasOwnProperty("nodeContentAlign")) {				nodeConf.nodeContentAlign = node.nodeContentAlign;			}			if(node.hasOwnProperty("nodeContentAlpha")) {				nodeConf.nodeContentAlpha = node.nodeContentAlpha;			}						addButton(nodeConf);		}				public function addButton(config):void {						var nodeBtn:NodeButton = new NodeButton(config);			var coords:Point = position(_buttons.length,config.initialDiameter,_angleOffset);			nodeBtn.x = coords.x;			nodeBtn.y = coords.y;			nodeBtn.name = config.nodeName;						_buttons.push(nodeBtn);		}				private function position(currentCount:uint,nodeDiameter:Number,degreeOffset:Number=0):Point {			var angle:Number = (_buttons.length*(360/_nodeCount));			var radians:Number = angle*(Math.PI/180)+degrees2radians(degreeOffset);			var radius:Number = _nodeOffset;			var position = Point.polar(radius,radians);						return position;		}				private function degrees2radians(degree) {			degree %= 360;			return degree * (Math.PI / 180);		}				private function displayButtons():void {			for each(var button:NodeButton in _buttons) {				button.width = 0;				button.height = 0;				addChild(button);			}		}				private function createHitArea():void {			_hitArea = new Sprite();			_hitArea.graphics.beginFill(0xff0000,0);			_hitArea.graphics.drawCircle(_origin.x,_origin.y,_nodeOffset+(_nodeFinalDiameter/2));			_hitArea.graphics.endFill();			_hitArea.visible = false;			addChildAt(_hitArea,0);			hitArea = _hitArea;						this._width = _hitArea.width;			this._height = _hitArea.height;		}				private function buttonTweenInit(buttonWidth:Number=0,buttonHeight:Number=0):NodeButton {			var button:NodeButton = _buttonsTween.shift();			button.width = buttonWidth;			button.height = buttonHeight;			return button;		}				private function tweenDelayComplete(e:TimerEvent=null) {						var button = _currentTweenButton;			TweenMax.to(button, 1, {autoAlpha:button.initialAlpha,setActualSize:{width:button.initialDiameter, height:button.initialDiameter}, roundProps:["width","height"], ease:Elastic.easeOut});		}				private function activateMenu():void {			if(!stage.hasEventListener(MouseEvent.MOUSE_MOVE)) {				stage.addEventListener(MouseEvent.MOUSE_MOVE,mouseMove_handler);				_buttonsTween = createNewButtonsArray(_buttons);								_mainBtn.buttonMode = true;				displayButtons();				_mainBtn.removeMouseOut();								_buttonsTweenSorted = false;				_currentTweenIndex = 0;			}						/* How the nodes will disappear */			if(_openEffect != 3) {				if(!_buttonsTweenSorted) {					if(_openEffect == 2) {						_buttonsTween.reverse(); // reverse order					} else if(_openEffect == 4) {						_buttonsTween = shuffleArray(_buttonsTween); // random order					}					_buttonsTweenSorted = true;				}			} else {				_buttonsTween.reverse();			}			if(_buttonsTween.length>0) {				_currentTweenIndex++;				var button:NodeButton = buttonTweenInit();				button.filters = null;								_currentTweenButton = button;								button.addMouseOver();								//_tweenDelay = new Timer(1000,1);				//_tweenDelay.addEventListener(TimerEvent.TIMER_COMPLETE,tweenDelayComplete);				//_tweenDelay.start();								//tweenDelayComplete();				TweenMax.to(button, 1, {autoAlpha:button.initialAlpha,setActualSize:{width:button.initialDiameter, height:button.initialDiameter}, roundProps:["width","height"], ease:Elastic.easeOut, easeParams:['1.2']});			} else {				menuActive = true;				dispatchEvent(new NodeEvent(NodeEvent.MENU_OPEN));			}		}				private function disableMenu():void {			if(stage.hasEventListener(MouseEvent.MOUSE_MOVE)) {				stage.removeEventListener(MouseEvent.MOUSE_MOVE,mouseMove_handler);				_buttonsTween = createNewButtonsArray(_buttons);				_mainBtn.buttonMode = true;				_buttonsTweenSorted = false;			}						if(menuActive) {				/* How the nodes will disappear */				if(_closeEffect != 3) {					if(!_buttonsTweenSorted) {						if(_closeEffect == 2) {							_buttonsTween.reverse(); // reverse order						} else if(_closeEffect == 4) {							_buttonsTween = shuffleArray(_buttonsTween); // random order						}						_buttonsTweenSorted = true;					}				} else {					_buttonsTween.reverse();				}				/* THE FOLLOWING WILL COLLAPSE ALL NODE BUTTONS SIMULTANEOUSLY */				/*var i:uint = 0;				for each(var button:NodeButton in _buttons) {					button.removeMouseOver();					button.buttonMode = false;					TweenMax.to(button, .4, {autoAlpha:0,blurFilter:{blurX:25, blurY:25, quality:2, remove:true},setActualSize:{width:0, height:0}, roundProps:["width","height"], ease:Back.easeIn, easeParams:['3']});				}				menuActive = false;*/								/* THE FOLLOWING WILL COLLAPSE ALL NODE BUTTONS IN A CHAIN */				if(_buttonsTween.length>0) {					var button:NodeButton = buttonTweenInit(_buttonsTween[0].width,_buttonsTween[0].height);					_currentTweenButton = button;										button.buttonMode = false;					button.removeMouseOver();					_mainBtn.removeMouseOut();										TweenMax.to(button, .4, {autoAlpha:.8,blurFilter:{blurX:25, blurY:25, quality:2, remove:true},setActualSize:{width:0, height:0}, roundProps:["width","height"], ease:Back.easeIn, easeParams:['3']});					}				else {					menuActive = false;				}			} else {				dispatchEvent(new NodeEvent(NodeEvent.MENU_CLOSED));				_mainBtn.addMouseOut();			}		}				private function createNewButtonsArray(sourceArr:Array):Array {			var targetArr:Array = new Array(_nodeCount);			for(var i:uint=0;i<_nodeCount;i++) {				targetArr[i] = sourceArr[i];			}			return targetArr;		}				private function mouseMove_handler(e:MouseEvent):void {			if(menuActive) {				var mouseLoc:Point = localToGlobal(new Point(mouseX,mouseY));							if(!hitTestPoint(mouseLoc.x,mouseLoc.y,true)) {					_mainBtn.closeNode();				}			}		}				function shuffleArray(arr:Array):Array {			var len:int = arr.length;			var temp:*;			var i:int = len;			while (i--) {				var rand:int = Math.floor(Math.random() * len);				temp = arr[i];				arr[i] = arr[rand];				arr[rand] = temp;			}			return arr;		}			} // end of class	} // end of package